; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__F66CEB67_corecrt_stdio_config@h DB 01H
__101834BA_corecrt_wstdio@h DB 01H
__AD6A91B7_stdio@h DB 01H
__F7309570_SDL_stdinc@h DB 01H
__DEF1ED59_SDL_endian@h DB 01H
__09340588_corecrt_math@h DB 01H
__B0C4CEA9_malloc@h DB 01H
__D291391D_SDL_rect@h DB 01H
__367CC694_corecrt_memcpy_s@h DB 01H
__DC9673E3_corecrt_wstring@h DB 01H
__A29A7DFB_string@h DB 01H
__00B5510B_grid@c DB 01H
msvcjmc	ENDS
PUBLIC	grid_init
PUBLIC	grid_valid_index
PUBLIC	grid_set_data_at
PUBLIC	grid_world_to_grid
PUBLIC	grid_grid_to_world
PUBLIC	grid_open_neighbours_at
PUBLIC	grid_check_node_data
PUBLIC	grid_draw
PUBLIC	grid_free_nodes
PUBLIC	__JustMyCode_Default
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e800000
PUBLIC	__real@3f000000
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	SDL_SetRenderDrawColor:PROC
EXTRN	SDL_RenderDrawRect:PROC
EXTRN	SDL_RenderFillRect:PROC
EXTRN	memset:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$grid_init DD imagerel $LN4
	DD	imagerel $LN4+287
	DD	imagerel $unwind$grid_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$grid_valid_index DD imagerel $LN7
	DD	imagerel $LN7+159
	DD	imagerel $unwind$grid_valid_index
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$grid_set_data_at DD imagerel $LN6
	DD	imagerel $LN6+309
	DD	imagerel $unwind$grid_set_data_at
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$grid_world_to_grid DD imagerel $LN3
	DD	imagerel $LN3+133
	DD	imagerel $unwind$grid_world_to_grid
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$grid_grid_to_world DD imagerel $LN3
	DD	imagerel $LN3+368
	DD	imagerel $unwind$grid_grid_to_world
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$grid_open_neighbours_at DD imagerel $LN31
	DD	imagerel $LN31+930
	DD	imagerel $unwind$grid_open_neighbours_at
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$grid_check_node_data DD imagerel $LN3
	DD	imagerel $LN3+122
	DD	imagerel $unwind$grid_check_node_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$grid_draw DD imagerel $LN12
	DD	imagerel $LN12+1005
	DD	imagerel $unwind$grid_draw
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$grid_free_nodes DD imagerel $LN3
	DD	imagerel $LN3+96
	DD	imagerel $unwind$grid_free_nodes
pdata	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$grid_free_nodes DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$grid_draw DD 035064119H
	DD	01143319H
	DD	0700d004aH
	DD	0500b600cH
	DD	imagerel __GSHandlerCheck
	DD	0248H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
grid_draw$rtcName$0 DB 069H
	DB	06eH
	DB	064H
	DB	065H
	DB	078H
	DB	00H
	ORG $+2
grid_draw$rtcName$1 DB 072H
	DB	065H
	DB	063H
	DB	074H
	DB	00H
	ORG $+3
grid_draw$rtcName$2 DB 072H
	DB	065H
	DB	063H
	DB	074H
	DB	032H
	DB	00H
	ORG $+2
grid_draw$rtcName$3 DB 072H
	DB	065H
	DB	063H
	DB	074H
	DB	032H
	DB	00H
	ORG $+2
grid_draw$rtcName$4 DB 072H
	DB	065H
	DB	063H
	DB	074H
	DB	033H
	DB	00H
	ORG $+2
grid_draw$rtcFrameData DD 05H
	DD	00H
	DQ	FLAT:grid_draw$rtcVarDesc
	ORG $+8
grid_draw$rtcVarDesc DD 0148H
	DD	010H
	DQ	FLAT:grid_draw$rtcName$4
	DD	0118H
	DD	010H
	DQ	FLAT:grid_draw$rtcName$3
	DD	0e8H
	DD	010H
	DQ	FLAT:grid_draw$rtcName$2
	DD	058H
	DD	010H
	DQ	FLAT:grid_draw$rtcName$1
	DD	038H
	DD	08H
	DQ	FLAT:grid_draw$rtcName$0
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$grid_check_node_data DD 025053401H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$grid_open_neighbours_at DD 025054a19H
	DD	011d2322H
	DD	070160037H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	01a0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
grid_open_neighbours_at$rtcName$0 DB 062H
	DB	06cH
	DB	06fH
	DB	063H
	DB	06bH
	DB	065H
	DB	064H
	DB	00H
grid_open_neighbours_at$rtcName$1 DB 06eH
	DB	065H
	DB	069H
	DB	067H
	DB	068H
	DB	062H
	DB	06fH
	DB	075H
	DB	072H
	DB	05fH
	DB	069H
	DB	06eH
	DB	064H
	DB	065H
	DB	063H
	DB	065H
	DB	073H
	DB	00H
	ORG $+6
grid_open_neighbours_at$rtcVarDesc DD 068H
	DD	020H
	DQ	FLAT:grid_open_neighbours_at$rtcName$1
	DD	044H
	DD	04H
	DQ	FLAT:grid_open_neighbours_at$rtcName$0
	ORG $+96
grid_open_neighbours_at$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:grid_open_neighbours_at$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$grid_grid_to_world DD 025053401H
	DD	0118231dH
	DD	070110025H
	DD	05010H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
grid_grid_to_world$rtcName$0 DB 074H
	DB	06fH
	DB	05fH
	DB	072H
	DB	065H
	DB	074H
	DB	075H
	DB	072H
	DB	06eH
	DB	00H
	ORG $+2
grid_grid_to_world$rtcName$1 DB 06fH
	DB	066H
	DB	066H
	DB	073H
	DB	065H
	DB	074H
	DB	00H
	ORG $+13
grid_grid_to_world$rtcVarDesc DD 048H
	DD	08H
	DQ	FLAT:grid_grid_to_world$rtcName$1
	DD	028H
	DD	08H
	DQ	FLAT:grid_grid_to_world$rtcName$0
	ORG $+96
grid_grid_to_world$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:grid_grid_to_world$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$grid_world_to_grid DD 025052f01H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
grid_world_to_grid$rtcName$0 DB 074H
	DB	06fH
	DB	05fH
	DB	072H
	DB	065H
	DB	074H
	DB	075H
	DB	072H
	DB	06eH
	DB	00H
	ORG $+6
grid_world_to_grid$rtcVarDesc DD 028H
	DD	08H
	DQ	FLAT:grid_world_to_grid$rtcName$0
	ORG $+48
grid_world_to_grid$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:grid_world_to_grid$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$grid_set_data_at DD 025053901H
	DD	011d2322H
	DD	070160021H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$grid_valid_index DD 025052f01H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$grid_init DD 025053901H
	DD	011d2322H
	DD	070160025H
	DD	05015H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\CPP-Programming\Lama\Lama\Lama\grid.c
;	COMDAT grid_free_nodes
_TEXT	SEGMENT
p_grid$ = 224
grid_free_nodes PROC					; COMDAT

; 39   : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__00B5510B_grid@c
	call	__CheckForDebuggerJustMyCode

; 40   :     free(p_grid->nodes);

	mov	rax, QWORD PTR p_grid$[rbp]
	mov	rcx, QWORD PTR [rax+16]
	call	QWORD PTR __imp_free

; 41   :     p_grid->nodes = NULL;

	mov	rax, QWORD PTR p_grid$[rbp]
	mov	QWORD PTR [rax+16], 0

; 42   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
grid_free_nodes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\CPP-Programming\Lama\Lama\Lama\grid.c
;	COMDAT grid_draw
_TEXT	SEGMENT
index$ = 8
rect$ = 40
temp$ = 88
y$8 = 116
x$9 = 148
rect2$10 = 184
rect2$11 = 232
rect3$12 = 280
rest$13 = 324
__$ArrayPad$ = 536
p_renderer$ = 576
p_grid$ = 584
grid_draw PROC						; COMDAT

; 129  : {

$LN12:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 592				; 00000250H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 148				; 00000094H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+632]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__00B5510B_grid@c
	call	__CheckForDebuggerJustMyCode

; 130  :     vector2     index;
; 131  :     SDL_Rect    rect;
; 132  :     node*       temp    = NULL;

	mov	QWORD PTR temp$[rbp], 0

; 133  : 
; 134  :     for(int y = 0; y < p_grid->dimensions.y; y++)

	mov	DWORD PTR y$8[rbp], 0
	jmp	SHORT $LN4@grid_draw
$LN2@grid_draw:
	mov	eax, DWORD PTR y$8[rbp]
	inc	eax
	mov	DWORD PTR y$8[rbp], eax
$LN4@grid_draw:
	mov	rax, QWORD PTR p_grid$[rbp]
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR y$8[rbp], eax
	jge	$LN3@grid_draw

; 135  :     {
; 136  :         for(int x = 0; x < p_grid->dimensions.x; x++)

	mov	DWORD PTR x$9[rbp], 0
	jmp	SHORT $LN7@grid_draw
$LN5@grid_draw:
	mov	eax, DWORD PTR x$9[rbp]
	inc	eax
	mov	DWORD PTR x$9[rbp], eax
$LN7@grid_draw:
	mov	rax, QWORD PTR p_grid$[rbp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR x$9[rbp], eax
	jge	$LN6@grid_draw

; 137  :         {
; 138  :             temp = &p_grid->nodes[y * p_grid->dimensions.x + x];

	mov	rax, QWORD PTR p_grid$[rbp]
	mov	ecx, DWORD PTR y$8[rbp]
	imul	ecx, DWORD PTR [rax+4]
	mov	eax, ecx
	add	eax, DWORD PTR x$9[rbp]
	cdqe
	mov	rcx, QWORD PTR p_grid$[rbp]
	mov	rcx, QWORD PTR [rcx+16]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR temp$[rbp], rax

; 139  :             rect.x =  x * p_grid->cell_size;

	mov	rax, QWORD PTR p_grid$[rbp]
	mov	ecx, DWORD PTR x$9[rbp]
	imul	ecx, DWORD PTR [rax]
	mov	eax, ecx
	mov	DWORD PTR rect$[rbp], eax

; 140  :             rect.y = y * p_grid->cell_size;

	mov	rax, QWORD PTR p_grid$[rbp]
	mov	ecx, DWORD PTR y$8[rbp]
	imul	ecx, DWORD PTR [rax]
	mov	eax, ecx
	mov	DWORD PTR rect$[rbp+4], eax

; 141  :             rect.w = p_grid->cell_size;

	mov	rax, QWORD PTR p_grid$[rbp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR rect$[rbp+8], eax

; 142  :             rect.h = p_grid->cell_size;

	mov	rax, QWORD PTR p_grid$[rbp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR rect$[rbp+12], eax

; 143  : 
; 144  :             index.x = x;

	mov	eax, DWORD PTR x$9[rbp]
	mov	DWORD PTR index$[rbp], eax

; 145  :             index.y = y;

	mov	eax, DWORD PTR y$8[rbp]
	mov	DWORD PTR index$[rbp+4], eax

; 146  :             if(grid_check_node_data(p_grid, index, HAS_GRASS))

	mov	r8d, 8
	mov	rdx, QWORD PTR index$[rbp]
	mov	rcx, QWORD PTR p_grid$[rbp]
	call	grid_check_node_data
	test	eax, eax
	je	SHORT $LN8@grid_draw

; 147  :             {
; 148  :                 // To show data and sprites of objects at the same time
; 149  :                 SDL_Rect rect2 = rect;

	lea	rax, QWORD PTR rect2$10[rbp]
	lea	rcx, QWORD PTR rect$[rbp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 150  :                 rect2.w *= 0.25f;

	cvtsi2ss xmm0, DWORD PTR rect2$10[rbp+8]
	mulss	xmm0, DWORD PTR __real@3e800000
	cvttss2si eax, xmm0
	mov	DWORD PTR rect2$10[rbp+8], eax

; 151  :                 rect2.h *= 0.25f;

	cvtsi2ss xmm0, DWORD PTR rect2$10[rbp+12]
	mulss	xmm0, DWORD PTR __real@3e800000
	cvttss2si eax, xmm0
	mov	DWORD PTR rect2$10[rbp+12], eax

; 152  : 
; 153  :                 SDL_SetRenderDrawColor(p_renderer,

	mov	BYTE PTR [rsp+32], 255			; 000000ffH
	xor	r9d, r9d
	mov	r8b, 125				; 0000007dH
	xor	edx, edx
	mov	rcx, QWORD PTR p_renderer$[rbp]
	call	SDL_SetRenderDrawColor

; 154  :                                        0,
; 155  :                                        125,
; 156  :                                        0,
; 157  :                                        255);
; 158  :                 SDL_RenderFillRect(p_renderer, &rect2);

	lea	rdx, QWORD PTR rect2$10[rbp]
	mov	rcx, QWORD PTR p_renderer$[rbp]
	call	SDL_RenderFillRect
$LN8@grid_draw:

; 159  :             }
; 160  :             if(grid_check_node_data(p_grid, index, HAS_SHEEP))

	mov	r8d, 16
	mov	rdx, QWORD PTR index$[rbp]
	mov	rcx, QWORD PTR p_grid$[rbp]
	call	grid_check_node_data
	test	eax, eax
	je	$LN9@grid_draw

; 161  :             {
; 162  :                 // To show data and sprites of objects at the same time
; 163  :                 SDL_Rect rect2 = rect;

	lea	rax, QWORD PTR rect2$11[rbp]
	lea	rcx, QWORD PTR rect$[rbp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 164  :                 rect2.x += 32;

	mov	eax, DWORD PTR rect2$11[rbp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR rect2$11[rbp], eax

; 165  :                 rect2.w *= 0.25f;

	cvtsi2ss xmm0, DWORD PTR rect2$11[rbp+8]
	mulss	xmm0, DWORD PTR __real@3e800000
	cvttss2si eax, xmm0
	mov	DWORD PTR rect2$11[rbp+8], eax

; 166  :                 rect2.h *= 0.25f;

	cvtsi2ss xmm0, DWORD PTR rect2$11[rbp+12]
	mulss	xmm0, DWORD PTR __real@3e800000
	cvttss2si eax, xmm0
	mov	DWORD PTR rect2$11[rbp+12], eax

; 167  : 
; 168  :                 SDL_SetRenderDrawColor(p_renderer,

	mov	BYTE PTR [rsp+32], 255			; 000000ffH
	mov	r9b, 255				; 000000ffH
	mov	r8b, 125				; 0000007dH
	xor	edx, edx
	mov	rcx, QWORD PTR p_renderer$[rbp]
	call	SDL_SetRenderDrawColor

; 169  :                                        0,
; 170  :                                        125,
; 171  :                                        255,
; 172  :                                        255);
; 173  :                 SDL_RenderFillRect(p_renderer, &rect2);

	lea	rdx, QWORD PTR rect2$11[rbp]
	mov	rcx, QWORD PTR p_renderer$[rbp]
	call	SDL_RenderFillRect
$LN9@grid_draw:

; 174  :             }
; 175  :             if(grid_check_node_data(p_grid, index, GRASS_LEVEL))

	mov	r8d, 7
	mov	rdx, QWORD PTR index$[rbp]
	mov	rcx, QWORD PTR p_grid$[rbp]
	call	grid_check_node_data
	test	eax, eax
	je	$LN10@grid_draw

; 176  :             {
; 177  :                 // To show data and sprites of objects at the same time
; 178  :                 SDL_Rect rect3 = rect;

	lea	rax, QWORD PTR rect3$12[rbp]
	lea	rcx, QWORD PTR rect$[rbp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 179  :                 rect3.w *= 0.25f;

	cvtsi2ss xmm0, DWORD PTR rect3$12[rbp+8]
	mulss	xmm0, DWORD PTR __real@3e800000
	cvttss2si eax, xmm0
	mov	DWORD PTR rect3$12[rbp+8], eax

; 180  :                 rect3.x += rect3.w;

	mov	eax, DWORD PTR rect3$12[rbp+8]
	mov	ecx, DWORD PTR rect3$12[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR rect3$12[rbp], eax

; 181  : 
; 182  :                 int rest = (int) (rect3.h * (1.0f / 5.0f));

	cvtsi2ss xmm0, DWORD PTR rect3$12[rbp+12]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	cvttss2si eax, xmm0
	mov	DWORD PTR rest$13[rbp], eax

; 183  : 
; 184  :                 rect3.h *= 0;

	imul	eax, DWORD PTR rect3$12[rbp+12], 0
	mov	DWORD PTR rect3$12[rbp+12], eax

; 185  :                 rect3.h += rest * grid_check_node_data(p_grid, index, GRASS_LEVEL);

	mov	r8d, 7
	mov	rdx, QWORD PTR index$[rbp]
	mov	rcx, QWORD PTR p_grid$[rbp]
	call	grid_check_node_data
	mov	ecx, DWORD PTR rest$13[rbp]
	imul	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR rect3$12[rbp+12]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR rect3$12[rbp+12], eax

; 186  :                 SDL_SetRenderDrawColor(p_renderer,

	mov	BYTE PTR [rsp+32], 255			; 000000ffH
	xor	r9d, r9d
	mov	r8b, 255				; 000000ffH
	xor	edx, edx
	mov	rcx, QWORD PTR p_renderer$[rbp]
	call	SDL_SetRenderDrawColor

; 187  :                                        0,
; 188  :                                        255,
; 189  :                                        0,
; 190  :                                        255);
; 191  :                 SDL_RenderFillRect(p_renderer, &rect3);

	lea	rdx, QWORD PTR rect3$12[rbp]
	mov	rcx, QWORD PTR p_renderer$[rbp]
	call	SDL_RenderFillRect
$LN10@grid_draw:

; 192  :             }
; 193  : 
; 194  :             SDL_SetRenderDrawColor(p_renderer,

	mov	rax, QWORD PTR p_grid$[rbp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR p_grid$[rbp]
	mov	ecx, DWORD PTR [rcx+24]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	rdx, QWORD PTR p_grid$[rbp]
	mov	edx, DWORD PTR [rdx+24]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16
	mov	rdi, QWORD PTR p_grid$[rbp]
	mov	edi, DWORD PTR [rdi+24]
	and	edi, -16777216				; ff000000H
	shr	edi, 24
	mov	BYTE PTR [rsp+32], al
	movzx	r9d, cl
	movzx	r8d, dl
	movzx	edx, dil
	mov	rcx, QWORD PTR p_renderer$[rbp]
	call	SDL_SetRenderDrawColor

; 195  :                                    (p_grid->color & 0xFF000000) >> 24,
; 196  :                                    (p_grid->color & 0x00FF0000) >> 16,
; 197  :                                    (p_grid->color & 0x0000FF00) >> 8,
; 198  :                                    p_grid->color & 0x000000FF);
; 199  : 
; 200  :             SDL_RenderDrawRect(p_renderer, &rect);

	lea	rdx, QWORD PTR rect$[rbp]
	mov	rcx, QWORD PTR p_renderer$[rbp]
	call	SDL_RenderDrawRect

; 201  :         }

	jmp	$LN5@grid_draw
$LN6@grid_draw:

; 202  :     }

	jmp	$LN2@grid_draw
$LN3@grid_draw:

; 203  : }

	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:grid_draw$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+544]
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
grid_draw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\CPP-Programming\Lama\Lama\Lama\grid.c
;	COMDAT grid_check_node_data
_TEXT	SEGMENT
p_grid$ = 224
p_index$ = 232
bitmask_index$ = 240
grid_check_node_data PROC				; COMDAT

; 88   : {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__00B5510B_grid@c
	call	__CheckForDebuggerJustMyCode

; 89   :     return (p_grid->nodes[p_index.y * p_grid->dimensions.x + p_index.x].data & bitmask_index);

	mov	rax, QWORD PTR p_grid$[rbp]
	mov	ecx, DWORD PTR p_index$[rbp+4]
	imul	ecx, DWORD PTR [rax+4]
	mov	eax, ecx
	add	eax, DWORD PTR p_index$[rbp]
	cdqe
	mov	rcx, QWORD PTR p_grid$[rbp]
	mov	rcx, QWORD PTR [rcx+16]
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, DWORD PTR bitmask_index$[rbp]

; 90   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
grid_check_node_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\CPP-Programming\Lama\Lama\Lama\grid.c
;	COMDAT grid_open_neighbours_at
_TEXT	SEGMENT
is_blocked$ = 4
blocked$ = 36
neighbour_indeces$ = 72
i$5 = 132
dir$6 = 164
tv208 = 372
tv204 = 372
tv195 = 372
tv180 = 372
tv168 = 372
tv78 = 372
tv75 = 372
tv70 = 372
tv65 = 372
tv210 = 376
tv170 = 376
__$ArrayPad$ = 384
p_grid$ = 432
out_open_neighbours$ = 440
out_open_count$ = 448
p_index$ = 456
p_block_value$ = 464
grid_open_neighbours_at PROC				; COMDAT

; 93   : {

$LN31:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 440				; 000001b8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 110				; 0000006eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+472]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__00B5510B_grid@c
	call	__CheckForDebuggerJustMyCode

; 94   :     bool    is_blocked = false;

	mov	BYTE PTR is_blocked$[rbp], 0

; 95   : 
; 96   :     (*out_open_count) = 0;

	mov	rax, QWORD PTR out_open_count$[rbp]
	mov	DWORD PTR [rax], 0

; 97   : 
; 98   :     // Consider edges of grid
; 99   :     bool    blocked[NUM_DIRS] = { !(p_index.y > 0),

	cmp	DWORD PTR p_index$[rbp+4], 0
	jg	SHORT $LN9@grid_open_
	mov	DWORD PTR tv65[rbp], 1
	jmp	SHORT $LN10@grid_open_
$LN9@grid_open_:
	mov	DWORD PTR tv65[rbp], 0
$LN10@grid_open_:
	movzx	eax, BYTE PTR tv65[rbp]
	mov	BYTE PTR blocked$[rbp], al
	mov	rax, QWORD PTR p_grid$[rbp]
	mov	eax, DWORD PTR [rax+4]
	dec	eax
	cmp	DWORD PTR p_index$[rbp], eax
	jl	SHORT $LN11@grid_open_
	mov	DWORD PTR tv70[rbp], 1
	jmp	SHORT $LN12@grid_open_
$LN11@grid_open_:
	mov	DWORD PTR tv70[rbp], 0
$LN12@grid_open_:
	movzx	eax, BYTE PTR tv70[rbp]
	mov	BYTE PTR blocked$[rbp+1], al
	mov	rax, QWORD PTR p_grid$[rbp]
	mov	eax, DWORD PTR [rax+8]
	dec	eax
	cmp	DWORD PTR p_index$[rbp+4], eax
	jl	SHORT $LN13@grid_open_
	mov	DWORD PTR tv75[rbp], 1
	jmp	SHORT $LN14@grid_open_
$LN13@grid_open_:
	mov	DWORD PTR tv75[rbp], 0
$LN14@grid_open_:
	movzx	eax, BYTE PTR tv75[rbp]
	mov	BYTE PTR blocked$[rbp+2], al
	cmp	DWORD PTR p_index$[rbp], 0
	jg	SHORT $LN15@grid_open_
	mov	DWORD PTR tv78[rbp], 1
	jmp	SHORT $LN16@grid_open_
$LN15@grid_open_:
	mov	DWORD PTR tv78[rbp], 0
$LN16@grid_open_:
	movzx	eax, BYTE PTR tv78[rbp]
	mov	BYTE PTR blocked$[rbp+3], al

; 100  :                                   !(p_index.x < (p_grid->dimensions.x - 1)),
; 101  :                                   !(p_index.y < (p_grid->dimensions.y - 1)),
; 102  :                                   !(p_index.x > 0) };
; 103  : 
; 104  :     // Init neighbours of center/origin
; 105  :     vector2 neighbour_indeces[NUM_DIRS] = { { p_index.x + 0, p_index.y - 1 },

	mov	eax, DWORD PTR p_index$[rbp]
	mov	DWORD PTR neighbour_indeces$[rbp], eax
	mov	eax, DWORD PTR p_index$[rbp+4]
	dec	eax
	mov	DWORD PTR neighbour_indeces$[rbp+4], eax
	mov	eax, DWORD PTR p_index$[rbp]
	inc	eax
	mov	DWORD PTR neighbour_indeces$[rbp+8], eax
	mov	eax, DWORD PTR p_index$[rbp+4]
	mov	DWORD PTR neighbour_indeces$[rbp+12], eax
	mov	eax, DWORD PTR p_index$[rbp]
	mov	DWORD PTR neighbour_indeces$[rbp+16], eax
	mov	eax, DWORD PTR p_index$[rbp+4]
	inc	eax
	mov	DWORD PTR neighbour_indeces$[rbp+20], eax
	mov	eax, DWORD PTR p_index$[rbp]
	dec	eax
	mov	DWORD PTR neighbour_indeces$[rbp+24], eax
	mov	eax, DWORD PTR p_index$[rbp+4]
	mov	DWORD PTR neighbour_indeces$[rbp+28], eax

; 106  :                                             { p_index.x + 1, p_index.y + 0 },
; 107  :                                             { p_index.x - 0, p_index.y + 1 },
; 108  :                                             { p_index.x - 1, p_index.y + 0 } };
; 109  :     // if open_direction is index equal to center/origin, it counts as invalid
; 110  :     for(int i = 0; i < NUM_DIRS; i++)

	mov	DWORD PTR i$5[rbp], 0
	jmp	SHORT $LN4@grid_open_
$LN2@grid_open_:
	mov	eax, DWORD PTR i$5[rbp]
	inc	eax
	mov	DWORD PTR i$5[rbp], eax
$LN4@grid_open_:
	cmp	DWORD PTR i$5[rbp], 4
	jge	SHORT $LN3@grid_open_

; 111  :         out_open_neighbours[i] = p_index;

	movsxd	rax, DWORD PTR i$5[rbp]
	mov	rcx, QWORD PTR out_open_neighbours$[rbp]
	mov	rdx, QWORD PTR p_index$[rbp]
	mov	QWORD PTR [rcx+rax*8], rdx
	jmp	SHORT $LN2@grid_open_
$LN3@grid_open_:

; 112  : 
; 113  :     // Check whether edge or neighbour blocks center/origin
; 114  :     // :: Get the open neighbours of certain position
; 115  :     for(int dir = 0; dir < NUM_DIRS; dir++)

	mov	DWORD PTR dir$6[rbp], 0
	jmp	SHORT $LN7@grid_open_
$LN5@grid_open_:
	mov	eax, DWORD PTR dir$6[rbp]
	inc	eax
	mov	DWORD PTR dir$6[rbp], eax
$LN7@grid_open_:
	cmp	DWORD PTR dir$6[rbp], 4
	jge	$LN6@grid_open_

; 116  :     {
; 117  :         is_blocked = blocked[dir] ||

	movsxd	rax, DWORD PTR dir$6[rbp]
	movzx	eax, BYTE PTR blocked$[rbp+rax]
	test	eax, eax
	jne	SHORT $LN17@grid_open_
	movsxd	rax, DWORD PTR dir$6[rbp]
	mov	r8d, DWORD PTR p_block_value$[rbp]
	mov	rdx, QWORD PTR neighbour_indeces$[rbp+rax*8]
	mov	rcx, QWORD PTR p_grid$[rbp]
	call	grid_check_node_data
	test	eax, eax
	jne	SHORT $LN17@grid_open_
	mov	DWORD PTR tv168[rbp], 0
	jmp	SHORT $LN18@grid_open_
$LN17@grid_open_:
	mov	DWORD PTR tv168[rbp], 1
$LN18@grid_open_:
	cmp	DWORD PTR tv168[rbp], 0
	jne	SHORT $LN19@grid_open_
	mov	DWORD PTR tv170[rbp], 0
	jmp	SHORT $LN20@grid_open_
$LN19@grid_open_:
	mov	DWORD PTR tv170[rbp], 1
$LN20@grid_open_:
	movzx	eax, BYTE PTR tv170[rbp]
	mov	BYTE PTR is_blocked$[rbp], al

; 118  :             grid_check_node_data(p_grid,
; 119  :                                neighbour_indeces[dir],
; 120  :                                p_block_value);
; 121  :         out_open_neighbours[(*out_open_count)].x = (is_blocked * p_index.x) + ((!is_blocked) * neighbour_indeces[dir].x);

	movzx	eax, BYTE PTR is_blocked$[rbp]
	test	eax, eax
	jne	SHORT $LN21@grid_open_
	mov	DWORD PTR tv180[rbp], 1
	jmp	SHORT $LN22@grid_open_
$LN21@grid_open_:
	mov	DWORD PTR tv180[rbp], 0
$LN22@grid_open_:
	movzx	eax, BYTE PTR is_blocked$[rbp]
	imul	eax, DWORD PTR p_index$[rbp]
	movsxd	rcx, DWORD PTR dir$6[rbp]
	mov	edx, DWORD PTR tv180[rbp]
	imul	edx, DWORD PTR neighbour_indeces$[rbp+rcx*8]
	mov	ecx, edx
	add	eax, ecx
	mov	rcx, QWORD PTR out_open_count$[rbp]
	movsxd	rcx, DWORD PTR [rcx]
	mov	rdx, QWORD PTR out_open_neighbours$[rbp]
	mov	DWORD PTR [rdx+rcx*8], eax

; 122  :         out_open_neighbours[(*out_open_count)].y = (is_blocked * p_index.y) + ((!is_blocked) * neighbour_indeces[dir].y);

	movzx	eax, BYTE PTR is_blocked$[rbp]
	test	eax, eax
	jne	SHORT $LN23@grid_open_
	mov	DWORD PTR tv195[rbp], 1
	jmp	SHORT $LN24@grid_open_
$LN23@grid_open_:
	mov	DWORD PTR tv195[rbp], 0
$LN24@grid_open_:
	movzx	eax, BYTE PTR is_blocked$[rbp]
	imul	eax, DWORD PTR p_index$[rbp+4]
	movsxd	rcx, DWORD PTR dir$6[rbp]
	mov	edx, DWORD PTR tv195[rbp]
	imul	edx, DWORD PTR neighbour_indeces$[rbp+rcx*8+4]
	mov	ecx, edx
	add	eax, ecx
	mov	rcx, QWORD PTR out_open_count$[rbp]
	movsxd	rcx, DWORD PTR [rcx]
	mov	rdx, QWORD PTR out_open_neighbours$[rbp]
	mov	DWORD PTR [rdx+rcx*8+4], eax

; 123  :         (*out_open_count) += !is_blocked;

	movzx	eax, BYTE PTR is_blocked$[rbp]
	test	eax, eax
	jne	SHORT $LN25@grid_open_
	mov	DWORD PTR tv204[rbp], 1
	jmp	SHORT $LN26@grid_open_
$LN25@grid_open_:
	mov	DWORD PTR tv204[rbp], 0
$LN26@grid_open_:
	mov	rax, QWORD PTR out_open_count$[rbp]
	mov	eax, DWORD PTR [rax]
	add	eax, DWORD PTR tv204[rbp]
	mov	rcx, QWORD PTR out_open_count$[rbp]
	mov	DWORD PTR [rcx], eax

; 124  :     }

	jmp	$LN5@grid_open_
$LN6@grid_open_:

; 125  :     return (*out_open_count) > NULL;

	mov	rax, QWORD PTR out_open_count$[rbp]
	movsxd	rax, DWORD PTR [rax]
	test	rax, rax
	jbe	SHORT $LN27@grid_open_
	mov	DWORD PTR tv208[rbp], 1
	jmp	SHORT $LN28@grid_open_
$LN27@grid_open_:
	mov	DWORD PTR tv208[rbp], 0
$LN28@grid_open_:
	cmp	DWORD PTR tv208[rbp], 0
	jne	SHORT $LN29@grid_open_
	mov	DWORD PTR tv210[rbp], 0
	jmp	SHORT $LN30@grid_open_
$LN29@grid_open_:
	mov	DWORD PTR tv210[rbp], 1
$LN30@grid_open_:
	movzx	eax, BYTE PTR tv210[rbp]

; 126  : }

	mov	edi, eax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:grid_open_neighbours_at$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+408]
	pop	rdi
	pop	rbp
	ret	0
grid_open_neighbours_at ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\CPP-Programming\Lama\Lama\Lama\grid.c
;	COMDAT grid_grid_to_world
_TEXT	SEGMENT
to_return$ = 8
offset$ = 40
p_grid$ = 288
p_grid_pos$ = 296
p_world_origin$ = 304
grid_grid_to_world PROC					; COMDAT

; 71   : {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__00B5510B_grid@c
	call	__CheckForDebuggerJustMyCode

; 72   :     vector2 to_return;
; 73   :     vector2 offset; 
; 74   :     offset.x = ((p_world_origin & ORIGIN_LEFT) * (int)(p_grid->cell_size * 0.5f)) -

	mov	eax, DWORD PTR p_world_origin$[rbp]
	and	eax, 8
	mov	rcx, QWORD PTR p_grid$[rbp]
	cvtsi2ss xmm0, DWORD PTR [rcx]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si ecx, xmm0
	imul	eax, ecx
	mov	ecx, DWORD PTR p_world_origin$[rbp]
	and	ecx, 2
	mov	rdx, QWORD PTR p_grid$[rbp]
	cvtsi2ss xmm0, DWORD PTR [rdx]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si edx, xmm0
	imul	ecx, edx
	sub	eax, ecx
	mov	DWORD PTR offset$[rbp], eax

; 75   :                ((p_world_origin & ORIGIN_RIGHT) * (int)(p_grid->cell_size * 0.5f));
; 76   :     offset.y = ((p_world_origin & ORIGIN_BOTTOM) * (int)(p_grid->cell_size * 0.5f)) -

	mov	eax, DWORD PTR p_world_origin$[rbp]
	and	eax, 4
	mov	rcx, QWORD PTR p_grid$[rbp]
	cvtsi2ss xmm0, DWORD PTR [rcx]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si ecx, xmm0
	imul	eax, ecx
	mov	ecx, DWORD PTR p_world_origin$[rbp]
	and	ecx, 1
	mov	rdx, QWORD PTR p_grid$[rbp]
	cvtsi2ss xmm0, DWORD PTR [rdx]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si edx, xmm0
	imul	ecx, edx
	sub	eax, ecx
	mov	DWORD PTR offset$[rbp+4], eax

; 77   :                ((p_world_origin & ORIGIN_TOP) * (int)(p_grid->cell_size * 0.5f));
; 78   : 
; 79   :     to_return.x = (int)(p_grid_pos.x * p_grid->cell_size) + (int)(p_grid->cell_size * 0.5f);

	mov	rax, QWORD PTR p_grid$[rbp]
	mov	ecx, DWORD PTR p_grid_pos$[rbp]
	imul	ecx, DWORD PTR [rax]
	mov	eax, ecx
	mov	rcx, QWORD PTR p_grid$[rbp]
	cvtsi2ss xmm0, DWORD PTR [rcx]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si ecx, xmm0
	add	eax, ecx
	mov	DWORD PTR to_return$[rbp], eax

; 80   :     to_return.y = (int)(p_grid_pos.y * p_grid->cell_size) + (int)(p_grid->cell_size * 0.5f);

	mov	rax, QWORD PTR p_grid$[rbp]
	mov	ecx, DWORD PTR p_grid_pos$[rbp+4]
	imul	ecx, DWORD PTR [rax]
	mov	eax, ecx
	mov	rcx, QWORD PTR p_grid$[rbp]
	cvtsi2ss xmm0, DWORD PTR [rcx]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si ecx, xmm0
	add	eax, ecx
	mov	DWORD PTR to_return$[rbp+4], eax

; 81   : 
; 82   :     to_return.x += offset.x;

	mov	eax, DWORD PTR offset$[rbp]
	mov	ecx, DWORD PTR to_return$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR to_return$[rbp], eax

; 83   :     to_return.y += offset.y;

	mov	eax, DWORD PTR offset$[rbp+4]
	mov	ecx, DWORD PTR to_return$[rbp+4]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR to_return$[rbp+4], eax

; 84   : 
; 85   :     return to_return;

	mov	rax, QWORD PTR to_return$[rbp]

; 86   : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:grid_grid_to_world$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
grid_grid_to_world ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\CPP-Programming\Lama\Lama\Lama\grid.c
;	COMDAT grid_world_to_grid
_TEXT	SEGMENT
to_return$ = 8
p_grid$ = 256
p_world_pos$ = 264
grid_world_to_grid PROC					; COMDAT

; 64   : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__00B5510B_grid@c
	call	__CheckForDebuggerJustMyCode

; 65   :     vector2 to_return;
; 66   :     to_return.x = (int)(p_world_pos.x / p_grid->cell_size);

	mov	eax, DWORD PTR p_world_pos$[rbp]
	cdq
	mov	rcx, QWORD PTR p_grid$[rbp]
	idiv	DWORD PTR [rcx]
	mov	DWORD PTR to_return$[rbp], eax

; 67   :     to_return.y = (int)(p_world_pos.y / p_grid->cell_size);

	mov	eax, DWORD PTR p_world_pos$[rbp+4]
	cdq
	mov	rcx, QWORD PTR p_grid$[rbp]
	idiv	DWORD PTR [rcx]
	mov	DWORD PTR to_return$[rbp+4], eax

; 68   :     return to_return;

	mov	rax, QWORD PTR to_return$[rbp]

; 69   : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:grid_world_to_grid$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
grid_world_to_grid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\CPP-Programming\Lama\Lama\Lama\grid.c
;	COMDAT grid_set_data_at
_TEXT	SEGMENT
temp$ = 8
tv87 = 212
p_grid$ = 256
p_index$ = 264
bitmask_index$ = 272
p_value$ = 280
grid_set_data_at PROC					; COMDAT

; 48   : {

$LN6:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__00B5510B_grid@c
	call	__CheckForDebuggerJustMyCode

; 49   :     node* temp = NULL;

	mov	QWORD PTR temp$[rbp], 0

; 50   : 
; 51   :     if(!grid_valid_index(p_index, p_grid->dimensions))

	mov	rax, QWORD PTR p_grid$[rbp]
	mov	rdx, QWORD PTR [rax+4]
	mov	rcx, QWORD PTR p_index$[rbp]
	call	grid_valid_index
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@grid_set_d

; 52   :         return false;

	xor	al, al
	jmp	$LN1@grid_set_d
$LN2@grid_set_d:

; 53   : 
; 54   :     temp = &p_grid->nodes[p_index.y * p_grid->dimensions.x + p_index.x];

	mov	rax, QWORD PTR p_grid$[rbp]
	mov	ecx, DWORD PTR p_index$[rbp+4]
	imul	ecx, DWORD PTR [rax+4]
	mov	eax, ecx
	add	eax, DWORD PTR p_index$[rbp]
	cdqe
	mov	rcx, QWORD PTR p_grid$[rbp]
	mov	rcx, QWORD PTR [rcx+16]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR temp$[rbp], rax

; 55   : 
; 56   :     // Reserve first three bits for value 1 to 7
; 57   :     // Reserve other bits as bools
; 58   :     temp->data = (temp->data & ~(bitmask_index));

	mov	rax, QWORD PTR temp$[rbp]
	movzx	eax, BYTE PTR [rax]
	mov	ecx, DWORD PTR bitmask_index$[rbp]
	not	ecx
	and	eax, ecx
	mov	rcx, QWORD PTR temp$[rbp]
	mov	BYTE PTR [rcx], al

; 59   :     temp->data |= ((bitmask_index * p_value) * !(bitmask_index & p_value));

	mov	eax, DWORD PTR p_value$[rbp]
	mov	ecx, DWORD PTR bitmask_index$[rbp]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LN4@grid_set_d
	mov	DWORD PTR tv87[rbp], 1
	jmp	SHORT $LN5@grid_set_d
$LN4@grid_set_d:
	mov	DWORD PTR tv87[rbp], 0
$LN5@grid_set_d:
	mov	eax, DWORD PTR bitmask_index$[rbp]
	imul	eax, DWORD PTR p_value$[rbp]
	imul	eax, DWORD PTR tv87[rbp]
	mov	rcx, QWORD PTR temp$[rbp]
	movzx	ecx, BYTE PTR [rcx]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR temp$[rbp]
	mov	BYTE PTR [rcx], al

; 60   :     temp->data |= (bitmask_index & p_value);

	mov	eax, DWORD PTR p_value$[rbp]
	mov	ecx, DWORD PTR bitmask_index$[rbp]
	and	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR temp$[rbp]
	movzx	ecx, BYTE PTR [rcx]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR temp$[rbp]
	mov	BYTE PTR [rcx], al

; 61   :     return true;

	mov	al, 1
$LN1@grid_set_d:

; 62   : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
grid_set_data_at ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\CPP-Programming\Lama\Lama\Lama\grid.c
;	COMDAT grid_valid_index
_TEXT	SEGMENT
tv67 = 192
tv69 = 196
p_index$ = 240
p_bounds$ = 248
grid_valid_index PROC					; COMDAT

; 44   : {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+280]
	lea	rcx, OFFSET FLAT:__00B5510B_grid@c
	call	__CheckForDebuggerJustMyCode

; 45   :     return (p_index.x * p_index.y) < (p_bounds.x * p_bounds.y);

	mov	eax, DWORD PTR p_index$[rbp]
	imul	eax, DWORD PTR p_index$[rbp+4]
	mov	ecx, DWORD PTR p_bounds$[rbp]
	imul	ecx, DWORD PTR p_bounds$[rbp+4]
	cmp	eax, ecx
	jge	SHORT $LN3@grid_valid
	mov	DWORD PTR tv67[rbp], 1
	jmp	SHORT $LN4@grid_valid
$LN3@grid_valid:
	mov	DWORD PTR tv67[rbp], 0
$LN4@grid_valid:
	cmp	DWORD PTR tv67[rbp], 0
	jne	SHORT $LN5@grid_valid
	mov	DWORD PTR tv69[rbp], 0
	jmp	SHORT $LN6@grid_valid
$LN5@grid_valid:
	mov	DWORD PTR tv69[rbp], 1
$LN6@grid_valid:
	movzx	eax, BYTE PTR tv69[rbp]

; 46   : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
grid_valid_index ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\CPP-Programming\Lama\Lama\Lama\grid.c
;	COMDAT grid_init
_TEXT	SEGMENT
size$ = 8
temp_nodes$ = 40
p_grid$ = 288
p_dimension$ = 296
p_cell_size$ = 304
p_color$ = 312
grid_init PROC						; COMDAT

; 12   : {

$LN4:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__00B5510B_grid@c
	call	__CheckForDebuggerJustMyCode

; 13   :     size_t  size        = 0;

	mov	QWORD PTR size$[rbp], 0

; 14   :     node*   temp_nodes  = NULL;

	mov	QWORD PTR temp_nodes$[rbp], 0

; 15   : 
; 16   :     if(!(((p_dimension.x * p_dimension.y) / p_cell_size) > 0) && p_grid)

	mov	eax, DWORD PTR p_dimension$[rbp]
	imul	eax, DWORD PTR p_dimension$[rbp+4]
	cdq
	idiv	DWORD PTR p_cell_size$[rbp]
	test	eax, eax
	jg	SHORT $LN2@grid_init
	cmp	QWORD PTR p_grid$[rbp], 0
	je	SHORT $LN2@grid_init

; 17   :         return false;

	xor	al, al
	jmp	$LN1@grid_init
$LN2@grid_init:

; 18   : 
; 19   :     // Create the grid outline
; 20   :     p_grid->cell_size   = p_cell_size;

	mov	rax, QWORD PTR p_grid$[rbp]
	mov	ecx, DWORD PTR p_cell_size$[rbp]
	mov	DWORD PTR [rax], ecx

; 21   :     p_grid->dimensions.x = (int)(p_dimension.x / p_cell_size);

	mov	eax, DWORD PTR p_dimension$[rbp]
	cdq
	idiv	DWORD PTR p_cell_size$[rbp]
	mov	rcx, QWORD PTR p_grid$[rbp]
	mov	DWORD PTR [rcx+4], eax

; 22   :     p_grid->dimensions.y = (int)(p_dimension.y / p_cell_size);

	mov	eax, DWORD PTR p_dimension$[rbp+4]
	cdq
	idiv	DWORD PTR p_cell_size$[rbp]
	mov	rcx, QWORD PTR p_grid$[rbp]
	mov	DWORD PTR [rcx+8], eax

; 23   :     p_grid->color       = p_color;

	mov	rax, QWORD PTR p_grid$[rbp]
	mov	ecx, DWORD PTR p_color$[rbp]
	mov	DWORD PTR [rax+24], ecx

; 24   : 
; 25   :     size = (Uint32)(p_grid->dimensions.x * p_grid->dimensions.y);

	mov	rax, QWORD PTR p_grid$[rbp]
	mov	rcx, QWORD PTR p_grid$[rbp]
	mov	eax, DWORD PTR [rax+4]
	imul	eax, DWORD PTR [rcx+8]
	mov	eax, eax
	mov	QWORD PTR size$[rbp], rax

; 26   : 
; 27   :     // Allocating the nodes for the grid
; 28   :     temp_nodes = (node*)calloc(size, sizeof(node));

	mov	edx, 1
	mov	rcx, QWORD PTR size$[rbp]
	call	QWORD PTR __imp_calloc
	mov	QWORD PTR temp_nodes$[rbp], rax

; 29   : 
; 30   :     // Set all node data to NULL by default
; 31   :     // Assign the created nodes to the grid
; 32   :     p_grid->nodes = (node*)memset(temp_nodes,

	mov	r8, QWORD PTR size$[rbp]
	xor	edx, edx
	mov	rcx, QWORD PTR temp_nodes$[rbp]
	call	memset
	mov	rcx, QWORD PTR p_grid$[rbp]
	mov	QWORD PTR [rcx+16], rax

; 33   :                                   NULL,
; 34   :                                   sizeof(node) * size);
; 35   : 
; 36   :     return true;

	mov	al, 1
$LN1@grid_init:

; 37   : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
grid_init ENDP
_TEXT	ENDS
END
